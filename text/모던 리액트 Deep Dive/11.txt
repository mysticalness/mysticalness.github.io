## 클래스 컴포넌트와 함수 컴포넌트


[보일러플레이트](https://charlezz.medium.com/%EB%B3%B4%EC%9D%BC%EB%9F%AC%ED%94%8C%EB%A0%88%EC%9D%B4%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%9E%80-boilerplate-code-83009a8d3297)


### 클래스 컴포넌트

* 클래스 컴포넌트 만드는 법
  1. 클래스 선언
  2. 만들고 싶은 컴포넌트를 extends
    * extends 구문에 넣을 수 있는 클래스
      - React.Component
      - React.PureComponent

### 클래스 컴포넌트의 생명주기 메서드
1. 마운트(mount) : 컴포넌트가 마운팅(생성)되는 시점
2. 업데이트(update) : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
3. 언마운트(unmount) : 컴포넌트가 더 이상 존재하지 않는 시점


* 생명주기 메서드
  * render()
  * componentDidMount()
  * componentDidUpdate()
  ...
  ...
  ...
  ...


* 클래스 컴포넌트의 한계
  * 데이터 흐름을 추적하기 어렵다
  * 애플리케이션 내부 로직의 재사용이 어렵다
  * 기능이 많아질수록 컴포넌트의 크기가 커진다.
  * 클래스 함수에 비해 상대적으로 어렵다
  * 코드 크기를 최적화하기 어렵다
  * 핫 리로딩을 하는 데 상대적으로 불리하다



* 함수 컴포넌트
 * 클래스 컴포넌트에 비해 간결
 * render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요도 없다
 * state가 각각의 원시값으로 관리되어 훨씬 사용하기 편해짐



### 함수 컴포넌트 vs 클래스 컴포넌트

* 생명주기 메서드의 부재
  * 클래스 컴포넌트의 생명주기 메서드가 함수 컴포넌트에서는 존재하지 않는다는 것.
  * 생명주기 메서드는 React.Component에서 오는 것

* 함수 컴포넌트와 렌더링된 값
  * 함수 컴포넌트 : props와 state를 기준으로 렌더링
  * 클래스 컴포넌트 : this 기준으로 렌더링