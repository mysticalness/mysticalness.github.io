2장 서브타입에 의한 다형성

2.1 객체와 서브타입

* 서브 타입에 의한 다형성 (Subtype Polymorphism)
  * 클래스 이름이 타입으로 사용한다.
  * 서브타입에 의한 다형성은, 객체를 사용할때 불편을 크게 줄여주는 윤활유 같은 존재.
  * Person 타입 클래스 ≠ Student 타입 클래스
  * 서브타입이라는 개념을 통해 다형성 실현
    * 서브타입 ? “A는 B다.”라는 타입 사이의 관계. 
                 “A는 B다.”라는 설정이 올바르다면 “A는 B의 서브타입이다.”
    * 슈퍼타입 ? A가 B의 서브타입이면 B가 A의 슈퍼타입이다.

    → A가 B의 서브타입일 때, A타입의 부품을 B의 타입의 부품으로도 간주할 수 있게 하는 기능.
      그러나, B타입의 부품을 A타입의 부품으로 사용 할 수는 없다.
      왜냐면, 서브타입이 가지고 있는 것을 슈퍼타입이 가지고 있지 않을 수 있음.

    * “A가 B다”라는 개념을 직관적으로 이해 + 타입 검사기가 사용하는 규칙을 고려 = 서브 타입 관계 파악.

  * 타입 검사기 객체 타입의 서브 타입 관계를 판단할 때 사용하는 규칙
    1. 이름에 의한 서브타입 (nominal subtyping)

      → 타입이 알려주는 이름을 바탕으로 서브 타입관계를 판단.

      * 클래스 A가 클래스 B를 상속 = A가 B의 서브타입
      * 클래스의 메서드, 필드는 고려 X
        * 직접상속 (direct inheritance) → 상속
        * 간접상속 (indirect inheritance)
         → 상속의 상속
         → 학교가 사람에게 상속. 사람이 학생에게 상속
         → 학생은 사람과 학교의 서브타입.
    2. 구조에 의한 서브타입 (structural subtyping)

      → 타입이 알려주는 구조를 바탕으로 서브 타입 관계를 판단.

      * 상속을 하지 않았지만 필드와 메서드를 보았을 때 서브 타입일 경우
      * A가 B에 정의된 필드와 메서드를 모두 정의한다면 A는 B의 서브타입이다.
      * 객체가 가지는 필드와 메서드를 그냥 나열한 것.
        ex) Void sendEmail ({String email;} person, String title, String content){
                    String email  = person.email;
                    ...
            }
    3. 추상 메서드
      * abstract  = 클래스와 객체를 직접 만들 수 없다.
      * 몸통 없이 이름, 매개변수 타입, 결과타입만 작성된 메서드
                            ↓
          * 메서드 시그니처(Signature)
            - 타입 검사할 때 메서드의 특징을 알려줌
            - 몸통이 없고 시그니처만 가짐.



      * 추상메서드를 가진 클래스는 객체를 직접 만들 수 없음.
        → 클래스 상속을 통해 새로운 클래스로부터 객체를 생성할 수 있음.
      * 추상클래스 (abstract class)
        - 추상메서드를 가지는 대신 객체를 직접 만들 수 없는 클래스
        - 언어에 따라, 인터페이스(Interface)나 트레이트(trait) 등의 용어 사용.

        → 추상클래스의 목적은 타입 검사기에 메서드의 존재를 제공하려는 목적일 뿐 
          객체를 만들기 위해서는 아니다. 때문에 객체를 만들지 못하는 것이 합리적이며 
          이 제약사항이 불편할 일이 없다.

        → 구조에 의한 서브타입을 제공한다면 추상메서드의 필요성이 줄어듦.

