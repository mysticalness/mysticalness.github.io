# 5장 오버로딩에 의한 다형성

## 5.1 오버로딩

* 함수 오버로딩(function overloading)
  * 한 함수가 여러 타입의 인자를 받아야 할 때 이거나 타입보다 훨씬 간단하고 직관적인 해결책을 제공하는 기능.
  * 함수 오버로딩
    * 같은 이름의 함수를 여러 개 정의하는 것. 단, 매개변수 타입은 서로 달라야 한다.
    * 함수 선택(function dispatch)
      * 함수가 오버로딩되어 있을 때 호출할 함수를 자동으로 고르는 것.
      * 인자의 타입에 맞는 함수를 고른다는 것.
    * 함수 오버로딩은 다형성을 만들어 내는 세번째 방법.

* 가장 특화된 함수
  * 인자의 타입에 가장 특화된(most specific) 함수를 고른다.
    * 벡터(vector)
      * 컴퓨터 그래픽스나 기계 학습 등 여러 분야에서 사용되는 개념.
      * 정수의 리스트. 정확히 말하면, 아무 수의 리스트나 다 벡터.
    * 희소 벡터(sparse vector)
      * 원소의 대부분이 0인 벡터.
    → 덜 특화된 함수와 더 특화된 함수를 모두 정의 
     = ‘가급적 더 특화된 함수를 사용하고 싶다.’는 암묵적인 요구 사항이 있는 것.
    → 함수 선택이 가장 특화된 함수를 고르는 게 매우 합리적.

  * ‘가장 특화된’, ‘더 특화된’
    * 한 함수의 매개변수 타입이 다른 함수의 매개변수 타입의 서브타입이라는 뜻.
    
  * 어떤 부품의 타입에는 두 종류가 있다.
    * 타입 검사기가 알고 있는 타입.
      * 정적 타입.
      * ‘실행하기 전에’

       → 실행하기 전에 타입 검사를 통해 알아낸 타입.

    * 가장 정확한 타입.
      * 동적 타입.
      * ‘실행하는 중에’

      → 실행하는 중에 진짜 값을 보고 알아낸 타입.

  * 정적 선택(static dispatch)
    * 대부분의 언어에서는 함수 선택 시에 정적 타입만을 고려.
    * 타입 검사를 통해 인자의 정적 타입을 알아낸 뒤, 실행하기 전에 호출할 함수를 미리 선택.
    * 정적 타입과 동적 타입 중 무엇을 고려할지 선택하는 것은 중요.
    → 정적 선택의 결과로 내 의도와는 다른 일이 일어날 수 있기 때문.  

* 메서드 오버로딩
  * 한 클래스에 이름이 같은 메서드를 여럿 정의하는 것.
  * 물론 이름이 같은 메서드들은 매개변수 타입이 서로 달라야 한다.

* 메서드 선택(method dispatch)
  * 인자의 타입에 맞는 메서드를 고른다.
  * 가장 특화된 메서드를 고른다.
  * 메서드를 고를 때는 인자의 정적 타입만 고려한다.



## 5.2 메서드 오버라이딩

* 메서드 오버라이딩
  * 특화된 동작을 정의하는 가장 좋은 방법.
  * 오버라이딩을 사용하면 서브타입을 위해 더 특화된 동작을 정의, 정적 타입에 상관없이 언제나 그 특화된 동작이 사용되도록 만들 수 있다.
  * 메서드 오버라이딩을 사용한 경우에도 ‘메서드 선택’이 일어난다.
    * 메서드 선택은 메서드 오버로딩뿐 아니라 메서드 오버라이딩까지도 모두 고려해 메서드를 선택한다.
    * 함수 선택은 인자의 정적 타입만 고려.
    * 메서드 선택은 인자의 정적 타입을 고려하는 것까지는 동일 + 수신자(receiver)의 동적 타입 역시 고려.
      * 수신자 = 메서드 호출 시에 메서드 이름 앞에 오는 객체.
    * 메서드 선택의 경우, 수신자의 동적 타입을 고려하여 실행 중에 메서드를 고르기 때문에 
      정적 선택이 아니라 ‘동적 선택(dynamic dispatch)’라고 부른다.

* 메서드 선택의 한계
  * 수신자의 동적 타입만 고려하고 인자의 동적 타입은 고려하지 않는다.
  → 문제점 : 인자의 정적 타입과 동적 타입이 다를 때는 개발자의 기대와 다른 메서드를 호출하게 된다.

* 메서드 오버라이딩
  * 결과 타입을 아무렇게나 해서는 안 된다.
    * 자식 클래스에 정의한 메서드 결과 타입이 부모 클래스에 원래 있는 메서드의 결과 타입의 서브타입이어야 한다.
    → 이런 다소 불편한 제약이 존재하는 이유는 동적 선택을 사용하면서도 타입 안전성을 지키기 위함.
    → 타입 검사기 실행 중에는 수신자의 동적 타입이 호출되는 메서드를 결정하기 때문.

