# 3장 매개변수에 의한 다형성

## 3.3 무엇이든 타입

* 무엇이든 타입(universally quantified type)
  * ‘보편 양화 타입’
  * forall T.A 형태 (T는 타입 매개변수, A는 타입), T가 무엇이든 될 수 있다.
  * 제네릭 함수의 타입이라고 이해할 수 있음.
  * 무엇이든 타입을 제네릭 함수의 타입이라고 이해할 수 있음.
  * 제네릭 함수를 값으로 사용하면 그 타입이 무엇이든 타입이 됨.
  * 무엇이든 타입의 값을 사용할 때는 제네릭 함수를 사용하듯이 하면 된다.
  * 제네릭 메서드를 가진 객체를 인자로 넘기기보다는 제네릭 함수를 바로 인자로 넘기는 편이 더 간결. → 무엇이든 타입이 요긴한 이유.
  * 최소 타입과 비슷.
    * 아무 값도 최소타입에 속하지 않듯 무엇이든 타입의 값을 만드는 것은 어려운 편.
    * 무엇이든 타입에 속하는 값은 얼마 없지만 사용하기는 매우 쉽다.
    * 최소 타입의 부품을 아무 데나 넣을 수 잇는 것과 비슷.
    * ‘무엇이든’ 할 수 있는 사람은 찾기 어려움. 다재다능.


## 3.4 무엇인가 타입

* 무엇인가 타입(existentially quantified type)
  * ‘존재 양화 타입’
  * 프로그램이 복잡할 때 무엇인가 타입의 진가가 드러난다.
  * exists T.A 형태(T는 타입 매개변수, A는 타입) = 무엇인가 타입
  * 정적 타입 언어가 제공하는 다른 대부분의 기능과는 목적이 다르다.
    * 타입 검사를 통과할 수 있는 프로그램이 타입 검사를 통과하지 못하도록 방해.
    * 라이브러리를 만들 경우 필요한 능력.
      * 라이브러리를 만드는 입장에서는 라이브러리 사용자의 행동을 제야할 필요가 있음.
→ 코드를 작성하기 쉽거나 앞으로 코드를 고치는 데 유리하기 때문.
  * 최대 타입과 비슷. 
    * 아무 값이나 최대 타입의 값이 될 수 있듯이 무엇인가 타입의 값을 만드는 것 역시 쉽다.
    * 무엇인가 타입의 값을 사용하는 방법 또한 제한적.
    * 무엇이든 타입에 속하는 값은 얼마 없다.
    * ‘무엇인가’할 수 있는 사람은 찾기 쉽다. 대신 ‘무엇인가’할 수 있는 사람에게는 그 사람이 잘할 수 있는 일을 찾아 줘야 한다. 아무거나 시켜서는 그 사람의 능력을 다 발휘하기 어려움.

