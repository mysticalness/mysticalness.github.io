# 5장 오버로딩에 의한 다형성

## 5.3 타입클래스

* 오버로딩에 의한 다형성을 매개변수에 의한 다형성과 함께 사용하는 방법.
  * gt함수를 오버로딩하여 만들 경우,
    * Problem → <T>가 아무타입이나 나타낼 수 있기에 T 타입 값이 gt의 인자로 사용될 수 있다는 보장이 없기 때문.
    * 해결방안 → gt(T,T) ? 타입클래스(typeclass)
      * 타입클래스(typeclass)
        * 특정 타입을 위한 어떤 함수가 존재한다.
        * 이름과 달리 클래스와 관련이 없음. 클래스가 X.
          타입을 나타내는 클래스는 더더욱 X.
        * 타입이 만족해야 하는 조건을 표현한다는 점에서 추상클래스와 비슷한 역할.
        * 타입클래스의 이름, 타입 매개변수, 함수목록을 명시해야 한다.
<br>
```
          typeclass comparable <T> {
            Boolean gt(T v1, T v2);
          }
```
          * 여러 함수를 요구하는 타입클래스를 정의할 수도 있음
          * 특정 타입을 어떤 타입클래스에 속하게 만들고 싶다면 타입클래스 인스턴스(typeclass instance)를 정의해야한다.
<br>
```
          instance Comparable<Int> {
            Boolean gt(Int v1, Int v2); { return v1 > v2; }
          }
```
          * “타입 Int가 Comparable 타입클래스에 속하며, 타입 클래스 Comparable이
            요구하는 함수 gt v1 > v2를 계산해 반환한다.”라는 뜻.
          * 타입 클래스 인스턴스에 정의된 함수는 그냥 오버로딩된 함수처럼 사용할 수 있음.
            ∴ 타입 클래스 인스턴스를 정의하는 일은 함수를 오버로딩하는 것과 거의 같다.
<br>
```
          Void sort<T>(List<T> lst) requires Comparable<T> {
              ...
              if(gt(lst[i], lst[j])) { ... }
          }
```
          * List<T> 타입의 리스트를 Sort인자로 넘기려면 T가 Comparable에 속해야 한다.” 라는 뜻.

        * 타입클래스의 장점
          → 추상 클래스보다 편하게 해주는 장점
          * 함수는 아무때나 정의 가능 But 메서드는 클래스를 정의할 때만 정의 할 수 있다.
            * ex) 라이브러리 <br> → 수정 불가능. 메서드 추가하려면 클래스를 수정해야함.
            * 타입클래스라면 문제 없다. Person 타입을 위한 gt함수를 작성함으로써 Person을 Comparable에 속하게 만들면 끝. <br> → Comparable<Person>
            ∴ 라이브러리에 정의된 타입을 특정 추상클래스의 서브타입으로 만드는 것 일반적으로 불가능. <br> → 이게 바로 타입 클래스의 가장 큰 장점.
                  
          * 제네릭 타입을 다룰 때 나타남
            * 추상클래스의 단점
              * 특정 타입 인자를 받는 제네릭 타입만이 만족하는 성질을 표현하기 어렵지만 타입 클래스로는 쉽게 가능.
<br>
```
              instance <T> comparable <List<T>> {}
```
            * 타입클래스 인스턴스를 타입 매개변수를 사용하여 한 번에 여러 타입을 속하게 만듦.
              = “각각의 타입 T마다 List<T>가 Comparable에 속한다.”라는 뜻.
          * 추상클래스로는 제네릭 타입이 타입 인자에 상관없이 항상 만족하는 성질만 표현할 수 있다. 
            그러나 타입클래스는 항상 만족하는 성질 + 특정 타입 인자를 받은 경우에만 만족하는 성질 역시 표현 가능.



## 5.4 카인드(Kind)

* 타입에도 여러 종류가 있다.
  * 어떤 타입을 “매개변수 타입이나 결과타입으로 사용할 수 있다”.
    ≒ 그 타입에 속하는 값이 존재한다는 것.
  * 어떤 타입 함수의 매개변수 타입이라는 말.
    ≒ 그 함수가 인자로 A타입의 값을 받는다는 뜻.
  * “A가 함수의 결과 타입이다.”
    ≒ 그 함수가 A 타입의 값을 반환한다.
  * 매개 변수 타입이나 결과 타입으로 사용될 수 있다.
    ≒ 그 타입에 속하는 값이 존재한다.
* 타입의 두 종류
  1. 그 타입의 값들이 존재하는 타입들.  *
  2. 타입 인자를 필요로 하는 타입들 ex) ArrayList, LinkedList
     그 타입의 값들이 존재하지 않는 타입들을 포함.   * => *

    → 설명하기 위해 도입된 개념 = 카인드(Kind) ≒ 곧 타입의 타입

      1) *  : 생략가능     2) * => *        3) (*,*) => *